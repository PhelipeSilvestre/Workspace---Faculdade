

**Spring Boot em Ação**


Parafraseando um livro muito conhecido sobre o framework Spring Boot, veremos ao longo desse módulo, tal ferramenta em ação. Para isso, construiremos uma API Restful composta pelas camadas Entity, Repository, Service e Controller. Além disso, veremos detalhes complementares de implementação, como o arquivo de propriedades do projeto e também o gerenciamento de dependências utilizando o Maven.


Antes de começarmos, você precisará ter em seu computador uma IDE (qualquer uma de sua preferência – eu sugiro a Spring Tool Suite). Caso queira visualizar a estrutura de bancos de dados do projeto (utilizaremos o banco de dados embarcado H2), instale também uma ferramenta como a DBeaver. Além disso, você também precisará da máquina virtual do Java. Sugiro que instale o JDK na versão 11. Todos esses softwares são gratuitos. Com tais ferramentas já instaladas, vamos dar início ao nosso projeto.


Para iniciarmos um projeto Spring, podemos utilizar a própria IDE ou, então (e, nesse caso, preferencialmente) um recurso disponibilizado pelo próprio Spring, o site start.spring.io.  Ao acessar o site por um navegador web, você visualizará a página demonstrada abaixo, na Figura 1 (na figura, já estará com as opções preenchidas e selecionadas). Antes de prosseguirmos, vamos entender essas opções disponíveis para criação de nosso projeto:


   Project: aqui você escolherá o gerenciador de dependências do projeto. Deixe a opção Maven Project selecionada (ou, caso já tenha familiaridade com o Gradle, escolha tal opção);

   Language: linguagens disponíveis. Deixa marcada a opção Java;

   Spring Boot: versões do framework. Deixe marcada a opção default, ou seja, 2.7.3;

   Project Metadata: as informações inseridas em Group e Artifact comporão o Package name de nosso projeto. Na prática, o caminho das pastas de nosso código. Há alguns padrões de mercado para preenchimento dessas informações, como iniciar o Group com “com” , “br.com” ou “org”, por exemplo. A seguir, depois do “.com” ou “org”, é comum ser inserido o nome da empresa ou organização responsável pelo projeto. Já em Artifact é comum inserirmos o nome do projeto. Em descrição você pode inserir uma descrição breve.

   Packaging: selecione Jar;

   Java: selecione a versão da máquina virtual java instalada em seu computador. Caso tenha instalado a versão 11, conforme sugerido acima, marque aqui a opção correspondente;

   Dependencies (do lado direito): aqui podemos selecionar as dependências (bibliotecas) que utilizaremos em nosso projeto. Há várias opções disponíveis. Nesse primeiro projeto, escolhe as mesmas dependências mostradas na Figura 1.



Após ter realizado as configurações acima, clique no botão “GENERATE”, ao final da página. Tal ação fará com que a estrutura do projeto seja baixada para o seu computador. A partir daqui, poderemos importar o projeto na IDE e começamos, então, a codificar.

   
![figure-01](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/3608dd7a-6e6f-4b4a-bc89-71cdcc1aaf22)

Figura 1: Página inicial do Spring initializr



O primeiro passo, após importação do projeto na IDE, consiste na criação dos “packages” para organização das camadas de nossa API. A Partir do package principal, você vai criar (se usou o package name sugerido na Figura 1, o mesmo será br.com.descomplica.projeto) os pacotes: entity, repository, service e controller. Com o projeto organizado e estruturado, em termos de packages (ou pastas/diretórios, caso tenha criado os mesmos a partir do sistema de arquivos, no seu sistema operacional), vamos começar a, efetivamente, codificar. Embora não haja um ponto certo a partir do qual começar, sugiro iniciarmos pelas Entidades. Logo, vamos realizar o mapeamento objeto relacional das tabelas e relações constantes no DER exibido a seguir, na Figura 2:



![figura-02](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/3d5ce970-bded-4c37-bd26-3058924012ad)

Figura 2: DER do Projeto




A partir do DER, podemos criar no package Entity, as classes correspondentes a cada tabela do banco, com exceção da tabela de ligação, “item_pedido”. Por se tratar de uma tabela de ligação que não possui colunas extras (possuindo apenas as chaves-primárias das tabelas relacionadas), tal tabela não precisará ser mapeada em uma entidade própria.


Nota: sugiro que você tente criar os códigos, sem olhar as respostas que serão disponibilizadas mais adiante, ao final desse módulo.

Seguem alguns lembretes:

   Inclua as anotações de classe e também as de atributos e relacionamentos;
   
   Em relação às anotações de relacionamento, analise o DER para entender a cardinalidade entre cada Entidade;
   
   Crie os métodos get e set (as IDEs costumam ter um atalho para geração desses métodos).


Depois de criar as entidades, seus atributos e também relacionamentos, podemos criar as interfaces no package Repository. Nesse sentido, crie uma interface para cada Entidade. Lembre-se de que, por uma questão de boas práticas, o nome de cada repositório deverá ser formado pelo nome da entidade seguido do sufixo Repository. Além disso, você deverá estender a interface JpaRepository. Nesse ponto, uma informação adicional: ao estender a JpaRepository, você deverá fornecer dois parâmetros dentro dos sinais “<>”, a saber: o nome da entidade e o tipo de dado com o qual você declarou o atributo que representa a chave-primária na entidade. Por exemplo: caso você tenha criado a Entidade “Produto” com um atributo chamado produtoId e declarar seu tipo como Integer, ao estender a JpaRepository, seu código ficará assim: “… extends JpaRepository<Produto, Integer>…”.


A criação das interfaces do pacote repository é a parte mais simples em nossa API – considerando que, na mesma, implementamos apenas os métodos CRUD. Após finalizada essa etapa, vamos criar os nossos serviços.



