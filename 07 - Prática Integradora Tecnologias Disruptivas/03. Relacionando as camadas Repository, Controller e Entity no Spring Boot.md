#Relacionando as camadas Repository, Controller e Entity no Spring Boot#

O Spring Boot se caracteriza por organizar o código em diferentes camadas. Ao longo desse módulo, veremos as camadas Repository, Controller e alguns relacionamentos mais complexos, aplicando-os na camada Entity. Além disso, veremos como essas três camadas se relacionam no framework em questão.

No Spring, a camada Repository é responsável pela persistência dos dados, trafegados ao longo da aplicação através da(s) instância(s) de uma ou mais Entidades no banco de dados. Logo, todas as operações relacionadas ao banco ficam sob responsabilidade dessa camada – sejam elas de recuperação, persistência, atualização ou deleção de registros. Diferente das Entities, no Repositório temos interfaces ao invés de classes. Além disso, cada Entidade deverá possuir sua própria interface na camada em questão, ou seja, se criarmos uma classe chamada Aluno na camada Entity, deveremos então criar uma interface, na camada Repository, chamada AlunoRepository. Repare, aqui, na convenção de se utilizar a palavra “Repository” como sufixo ao nome da Entidade. Isso ajuda a identificar, pelo nome do arquivo, a qual entidade um repositório se refere.

Outra característica importante e bastante conveniente do Spring Boot é permitir que nosso repositório implemente interfaces de repositório pré-existentes, como a JpaRepository, a CrudRepository e a PagingAndSortingRepository. Cada uma dessas interfaces possui uma série de métodos pré-implementados, dos quais poderemos fazer uso ao declarar nossa interface e informar que estenderemos uma delas. Em geral, utilizamos a JpaRepository (que, por sua vez, já estende às outras duas). Com isso, temos disponíveis vários métodos de manipulação de dados, como os relacionados ao CRUD (findById, findAll, save, delete, etc.), além de recursos como paginação e outros.

`
O código abaixo demonstra a implementação do repositório relativo à Entidade Aluno – à esquerda temos o código da Entity e à direita o do Repository.

    @Entity
    @Table(name="aluno")

    public class Aluno{
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)

    @Column(name="aluno_id")
    private Integer alunoId;

    @Column(name="aluno_nome")
    private String alunoNome;

    @ManyToOne
    @JoinColumn(name="turma_id")
    private Turma turma;

    //getters e setters

    }

    import
    org.springframwork.data.jpa.repository.JpaRepository;

    public interface AlunoRepository extends JpaRepository<Aluno, Integer> {
    }

`

Como podemos perceber, há uma relação interdependente entre a camada Entity e a Repository: ambas são necessárias e trabalham em conjunto para que os dados (a serem persistidos ou recuperados do banco de dados) transitem em nossa API. Na hierarquia de camadas do Spring Boot, podemos dizer que essas duas camadas são as de mais “baixo nível”, ou as que ficam mais próximas ao banco de dados. Por outro lado, temos então a camada que, seguindo essa mesma lógica, podemos chamar de camada de mais alto nível, a Controller.

A camada Controller, no Spring, contém classes responsáveis por responder a requisições HTTP/HTTPS. Logo, nela inserimos os recursos que queremos expor em nossa API/ e que queremos disponibilizar para serem utilizados por clientes, como outros sistemas de software, ou mesmo por outras aplicações em nosso próprio ecossistema, por exemplo, podemos ter um sistema composto por uma aplicação web e por um aplicativo mobile, em que ambos consomem serviços disponíveis em nossa API desenvolvida utilizando Spring, fazendo requisições sobre o protocolo HTTP, tendo como alvo a camada Controller. Isso posto, e seguindo o padrão do framework, devemos ter, não obrigatoriamente, mas de forma recomendada, uma classe na camada Controller para cada uma das entidades que compõem nossa API. Além disso, tais classes recebem algumas anotações especiais – anotações essas que, a nível de classe, informam que a classe em questão é um Controller do tipo REST (@RestController); e, a nível de recursos e serviços disponibilizados, representados pelos métodos que compõem a classe, o tipo de acesso a cada um deles (@GetMapping, @PostMapping, @PutMapping, @DeleteMapping e @PathMapping).

Considerando o repositório que criamos anteriormente, vejamos agora o controller correspondente:

    @RestController
    @RequestMapping("/aluno")

    public class AlunoController{
        @GetMapping
        public ResponseEntity<List<Aluno>>getAlunos(){
            //a implementar: chamada ao service correspondente
            return new ResponseEntity<>(listaAlunos, HttpStatus.OK);
        }

        @GetMapping("/{id}")
        public ResponseEntity<Aluno>getAlunoById("PathVariable Integer id){
            // a implementar: chamada ao service correspondente
            return new ResponseEntity<>(aluno, HttpStatus.OK);
        }

        @PostMapping
        public ResponseEntity <Aluno> saveAluno(@RequestBody Aluno aluno) {
            //a implementar: chamada ao service correspondente
            return new ResponseEntity <> (novoAluno, HttpStatus.CREATED);
        }

        @PutMapping("/{id}")
        public ResponseEntity <Aluno> updateAluno(@PathVariable Integer id, @RequestBody Aluno aluno) {
            //a implementar: chamada ao service correspondente
            return new ResponseEntity <> (alunoAtualizado, HttpStatus.OK);
        }

        @DeleteMapping("/{id}")
        public ResponseEntity <String> deleteAluno(@PathVariable Integer id) {
            //a implementar: chamada ao service correspondente
            return new ResponseEntity <> ("", HttpStatus.OK);
        }

    }


