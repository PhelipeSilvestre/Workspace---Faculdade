**Implementando o backend do projeto integrado**

Depois de construirmos os ambientes onde nosso projeto rodará, começaremos, então, a sua implementação. Seguindo uma ordem lógica, que nos permita, inclusive, testar todas as funcionalidades, faremos primeiro o backend – tendo em mente que o banco de dados já foi implementado na configuração dos ambientes, ficando pendente apenas a parte de autenticação. Nesse sentido, ao longo deste módulo, confeccionaremos a API Restful com o Spring Boot. Antes de continuarmos, quero lembrá-lo do que você vai precisar para essa tarefa:

  1. Banco de Dados Postgres (já configurado via Docker);

  2. Script de criação das tabelas (já executado na subida do docker);

  3. Complemento do script de criação de tabelas – incluiremos a parte de usuários/autenticação;

  4. IDE para codificação – eu utilizarei o Spring Tools Suite. Você pode utilizar essa ou outra ferramenta à sua escolha;

  5. Template do Projeto Spring, que pode ser gerado a partir do http://start.spring.io (Acesso em 20/10/2022) – inclusive, já geramos esse template no módulo anterior;

  6. Estrutura da pasta dos códigos do backend – também fizemos isso no último módulo;

  7. Swagger para testarmos a API, cuja dependência incluiremos em nosso pom.xml e também outra ferramenta, por exemplo, o Postman ou Insomnia, caso prefira testar a API fora do Swagger.


Bem, já podemos começar a colocar a mão na massa. Embora não exista, obrigatoriamente, uma camada pela qual devamos começar, eu gosto de iniciar pelas camadas mais baixas, ou seja, pelo mapeamento das tabelas, colunas e relacionamentos do banco de dados nas classes de Entidade. Após isso, faremos os repositórios. Contudo, vamos por partes. Abra o script contendo as tabelas do banco de dados (que será executado novamente quando formos subir o ambiente Docker) e adicione a seguinte instrução:

![1675971909942-fayJL0ZanW](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/9fbf32a8-cd30-4e65-bc0d-0541a914cc43)

DDL para criação da tabela usuario

Com a tabela acima, nosso modelo de banco de dados estará completo. Feito isso, vamos agora criar as entidades. Antes, e pra facilitar pra você, veja abaixo o template da aplicação. Perceba que já incluí aqui a dependência do Actuator.

![1675971933760-e7LkBHPJZm](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/1436f7bf-9835-432f-bea8-c19ad8707aca)

Figura 1: Template de Projeto Spring Boot

Ao gerar um novo zip ou aproveitando a estrutura do projeto que usamos no último módulo, e após ter incluído/conferido as dependências acima, edite o pom.xml e já inclua a dependência referente ao Springdoc e a java-jwt (usada na segurança da API). Nesse ponto, nosso pom.xml (apenas as dependências) deverá estar assim:

![1675972196996-l3BW5vItwn](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/5caadfac-0b15-4b2e-ac0f-f15cc7c07155)

​Vamos conferir uma última questão antes de continuarmos. A estrutura de pastas, considerando os packages do projeto, deve estar assim:

![1675972222677-x3EMf4dvsr](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/5c1fb403-4ae7-41a7-93b8-9bad14ce2bba)

Figura 2: Estrutura de pastas do projeto de backend

Pronto, agora temos, de fato, tudo o que precisamos para começarmos a codificar. Como já mencionado, começaremos pelas entidades. Inclusive, já temos a primeira pronta, que pode ser aproveitada do módulo 5. É a Entidade User. Copie a classe abaixo e a inclua na pasta “entity”.

https://github.com/FaculdadeDescomplica/pratica_integradora_tecnologias_disruptivas/blob/main/modulo5b/codigo_fonte/src/main/java/br/com/descomplica/projeto/seguranca/entity/User.java (Acesso em 20/10/2022)

Continuando, podemos aproveitar também a entidade Projeto, que criamos no módulo 13, e complementarmos com os atributos e anotações faltantes. Crie uma nova classe, chamada Projeto, dentro de “entity” e cole o código abaixo:

https://github.com/FaculdadeDescomplica/pratica_integradora_tecnologias_disruptivas/blob/main/modulo13/aplicacao/backend/src/main/java/com/projeto/integrado/entity/Projeto.java (Acesso em 20/10/2022)

Analisando a tabela projeto e as demais tabelas da aplicação, temos as seguintes relações a envolvendo:

 projeto x tarefa - do tipo 1:N, ou seja, um projeto pode ter várias tabelas; 
 
 projeto x gerente_projeto - do tipo N:N entre projeto e recurso, sendo refletida no banco pela tabela de ligação gerente_projeto).

Seguindo a lógica acima, ao criarmos a entidade Tarefa, também precisaremos criar as demais entidades com as quais ela se relaciona, ou seja, Recurso (já mencionada em relação a Projeto) e StatusTarefa. Frente a isso, podemos perceber que uma ação leva a outra, num efeito cascata. Logo, é importante aqui tomar cuidado para não deixar nenhuma entidade ou relação de fora. Ao terminar, volte e confira, comparando as entidades e as tabelas, se realizou todos os mapeamentos, incluindo os relacionamentos.

Para ajudá-lo nesse processo de mapeamento, aqui vão algumas dicas, começando pela tabela de ligação. Em nosso modelo físico, temos uma tabela de ligação, a “gerente_projeto”. Essa tabela indica existir uma relação N:N entre projeto e recurso. No Spring, os relacionamentos entre tabelas são realizados através de anotações específicas nas instâncias entre as entidades. Sobre esse relacionamento em particular, do tipo “muitos para muitos”, há diferentes formas de realizá-lo. Em nosso caso, especificamente, onde a tabela de ligação não possui atributo adicional, mas apenas as chaves estrangeiras das tabelas que ela relaciona, não precisaremos criar uma entidade para a tabela em questão. Com isso, o relacionamento será feito entre as entidades Projeto e Recurso. Veja o fragmento abaixo, onde esse relacionamento é implementado “dos dois lados”:

![1675972274590-q3vAF63SJC](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/8d9a9742-b27b-45bb-be92-a47402e0ec6a)


Na primeira parte do fragmento acima, temos o mapeamento realizado na entidade Projeto. A primeira anotação utilizada é a @ManyToMany que, como o nome indica, informa que trata-se de uma relação muitos para muitos. A seguir, temos a anotação @JoinTable, onde, em seus parâmetros, é informada a tabela, no banco de dados, responsável pela ligação, assim como as colunas – a joinColumns informa o nome da coluna, no banco de dados, dentro da tabela de ligação, referente à entidade atual/tabela referente à entidade atual, ou seja, projeto. Já na inverseJoinColumns é informada a outra coluna, referente ao outro lado da relação, ou seja, recurso_id da tabela/entidade recurso. Por fim, definimos o tipo de dados como uma coleção do tipo “Set” para a instância da entidade relacionada.

Na segunda parte do fragmento temos o mapeamento da relação sendo feito do outro lado, ou seja, na entidade Recurso. Aqui a anotação é simplificada, envolvendo apenas a @ManyToMany e o parâmetro mappedBy, em que informamos o nome da instância com a qual a relação foi anotada na entidade Projeto, que, como pode ser visto no primeiro fragmento, chama-se “gerentes”.

Seguindo essa mesma linha, a segunda dica também diz respeito a relacionamentos. Depois de falar sobre @ManyToMany, vamos falar dos demais necessários em nosso projeto, onde temos também o @OneToOne, entre Recurso e Tarefa; o @OneToMany entre Projeto e Tarefa / e seu inverso, o @ManyToOne entre Tarefa e Projeto. Nesse ponto cabe um adendo: o Spring trabalha com o conceito de relação bidirecional. Ou seja, quando anotamos a relação dos dois lados, ou seja, nas duas entidades envolvidas, conseguiremos, em termos de operações com essas entidades (como seleção/recuperação de dados) obter os resultados a partir das duas pontas. Para facilitar, vamos exemplificar: ao fazer a anotação de relação @OneToMany entre Projeto/Tarefa e @ManyToOne entre Tarefa/Projeto, conseguiremos obter:

  A partir de uma entidade Projeto, seus dados (representado por seus atributos) e uma lista de todas as tarefas relacionadas a esse projeto;
  
  A partir de uma entidade Tarefa, seus dados e também os dados do Projeto ao qual a tarefa está relacionada.

Tenha em mente que não é obrigatório anotarmos a relação “dos dois lados”. Logo, cada caso deve ser analisado e decidido levando em conta diversos fatores, como necessidade de negócio, real utilização de todos os dados encadeados (já que ligar as entidades dos dois lados aumenta a quantidade de dados trafegados), etc.

A última dica sobre relacionamentos, que é a parte mais sensível no mapeamento objeto relacional, é que o Spring usa um padrão quando realizamos as anotações de forma bi-direcional (nas duas entidades envolvidas). Veja mais esse fragmento, onde consta o relacionamento entre Tarefa e Recurso:

![1675972308271-bagu2o7iwe](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/aed33b7b-5a57-4d35-ad40-b6a8be3a23a1)

Repare que, também nessa relação, um dos lados a anotação de relacionamento simplificada, acompanhada do parâmetro mappedBy, enquanto, no outro lado, temos a anotação da relação acompanhada pela @JoinColumn, contendo como parâmetro as colunas, do banco de dados, responsáveis pelo relacionamento (a chave estrangeira e o seu nome nas duas tabelas envolvidas). Explicando em detalhes:

Na tabela tarefa consta a chave-estrangeira recurso_id. Essa coluna faz referência à tabela recurso, coluna recurso_id. Nesse relacionamento a chave-estrangeira e a chave-primária possuem o mesmo nome. Entretanto, o nome da chave-estrangeira, em algumas situações, por decisão do dev ou DBA, pode receber outro nome. Antes de seguirmos, veja abaixo a instrução SQL que cria essa relação entre as tabelas em questão:

    ALTER TABLE tarefa ADD CONSTRAINT fk_tarefa_recurso FOREIGN KEY ( recurso_id ) REFERENCES recurso( recurso_id );

Agora, repare no fragmento de código acima, que na entidade Tarefa, além do @OneToOne, incluímos também a anotação @JoinColumn, passando os parâmetros name e referencedColumnName. Em name colocamos o nome da chave-estrangeira (a coluna da tabela Tarefa) e em referencedColumnName o nome da chave-primária na tabela relacionada, ou seja, recurso_id .

Para fechar a parte do mapeamento que, inclusive, é a mais complicada de fazer, vou adicionar abaixo como os relacionamentos ficaram em cada Entidade, para que você possa comparar com o seu código.

![1675972326149-uJTdL3uHf6](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/eb82e9f1-8f20-475b-ac05-0051cce1538e)

Entidade Projeto


![1675972362491-Ac4UOb90yK](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/12594eeb-91c2-4619-88f5-71d4f1945c4e)

Entidade Tarefa


![1675972380920-MhHsgkDQKj](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/6f25fbf0-d978-49b7-bd39-d5b25450c286)

Entidade Recurso


![1675972390637-4lhX1K2XkC](https://github.com/PhelipeSilvestre/Workspace---Faculdade/assets/99892687/9fd0bfc8-d5b8-4932-9e7d-62e12317a7e4)

Entidade StatusTarefa























